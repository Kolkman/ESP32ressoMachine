//
// ESPressIoT Controller for Espresso Machines
// 2016-2021 by Roman Schmitz
//
// Web Server with Options and Plotter
//

//#define ELEGANT_OTA

#include "ESPressoMachine.h"
#include <PID_v1.h>

#include "webinterface.h"
#include "config.h"
#include <Arduino.h>

#include "webInterfaceAPI.h"

#ifdef ELEGANT_OTA
#include <AsyncElegantOTA.h>
#else
#include "webInterfaceOTAUpdate.h"
#endif

// Various WebSources:
//#include "pages/test.html.h"
#include "pages/ESPresso.css.h"
#include "pages/EspressoMachine.svg.h"
#include "pages/switch.css.h"
#include "pages/configuration.html.h"
#include "pages/configuration_helper.js.h"
#include "pages/drawtimeseries.js.h"
#include "pages/firmware.js.h"
#include "pages/gauge.min.js.h"
#include "pages/index.html.h"
#include "pages/index_helper.js.h"
#include "pages/redCircleCrossed.svg.h"
#include "pages/networkSetup.html.h"
#include "pages/networkConfigPage.js.h"
#include "pages/captivePortal.html.h"
#define ONCOLOR "CD212A"
#define OFFCOLOR "DCDCDC"

WebInterface::WebInterface(ESPressoMachine *machine, const char *username, const char *password)
{
  Serial.println("Webinterfce Constructor");
  _username = username;
  _password = password;
  server = new EspressoWebServer(80, username, password);
  myMachine = machine;
  events = new AsyncEventSource("/events");
  //  httpUpdater = new HTTPUpdateServer;
}

WebInterface::~WebInterface()
{
  Serial.println("Webinterfce Destructor");
}

void WebInterface::handleNotFound(AsyncWebServerRequest *request)
{
  String message = htmlHeader;
  message += "<H1>Error 400 <br/> File Not Found</H1>\n\n";
  message += "<div id=\"notFoundInfo\"><div id=\"notFoundURI\">URI: <span id=\"notFoundURL\">";
  message += request->url();
  message += "</span></div>\n<div id=\"notFoundMethod\">Method: ";
  message += (request->method() == HTTP_GET) ? "GET" : "POST";
  message += "</div>\n<div id=\"notFoundArguments\">Arguments: ";
  message += request->args();
  message += "</div>\n";

  for (uint8_t i = 0; i < request->args(); i++)
  {
    message += "<div class=\"notFoundArgument\"><span class=\"notFoundargName\">" + request->argName(i) + "</span>:<span class=\"notFoundarg\"> " + request->arg(i) + "</span></div>\n";
  }
  message += "</div>";
  message += htmlFooter;
  request->send(404, "text/html", message);
}

void WebInterface::handleRoot(AsyncWebServerRequest *request)
{
  request->redirect("/index.html");
}

void WebInterface::handleFile(AsyncWebServerRequest *request, const char *mimetype, const unsigned char *compressedData, const size_t compressedDataLen)
{
  AsyncWebServerResponse *response = request->beginResponse_P(200, mimetype, compressedData, compressedDataLen);
  response->addHeader("Server", "ESP Async Web Server");
  response->addHeader("Content-Encoding", "gzip");
  request->send(response);
}

void WebInterface::handleReset(AsyncWebServerRequest *request)
{
  String message = "<head><meta http-equiv=\"refresh\" content=\"2;url=/\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /><title>EspressIoT</title></head>";
  message += "<h1> Reseting Device ! </h1>";
  request->send(200, "text/html", message);
  delay(1000);
  ESP.restart();
}

void WebInterface::setupWebSrv(ESPressoMachine *machine)
{
  myMachine = machine;

  Serial.println("Setting up  Webserver");

  if (server == nullptr)
  {
    Serial.println("WEBinterface: Server NULLPTR - halting execution");
    while (true)
    {
      // Hang around infinitly...
      delay(1);
    }
  }

  if (events == nullptr)
  {

    Serial.println("WEBinterface: Events NULLPTR - halting execution");
    while (true)
    {
      // Hang around infinitly...
      delay(1);
    }
  }
  // httpUpdater->setup(server);
  // Serial.print("Updater running !");

  server->on("/", HTTP_GET, std::bind(&WebInterface::handleRoot, this, std::placeholders::_1));
  server->onNotFound(std::bind(&WebInterface::handleNotFound, this, std::placeholders::_1));
  server->on("/reset", HTTP_GET, std::bind(&WebInterface::handleReset, this, std::placeholders::_1));
  webAPI.begin(server, myMachine);

#ifdef ELEGANT_OTA
  AsyncElegantOTA.begin(server);
#else
  webOTAUpdate.begin(server);
#endif
  // These are definitions generated by make - all to serve
  // static webpages

  server->on("/configure", HTTP_GET, [&](AsyncWebServerRequest *request)
             { request->redirect("/configuration.html"); });
  server->on("/config", HTTP_GET, [&](AsyncWebServerRequest *request)
             { request->redirect("/configuration.html"); });

  server->on("/scan", HTTP_GET, std::bind(&WebInterface::handleScan, this, std::placeholders::_1));
  server->on("/configConfig", HTTP_GET, std::bind(&WebInterface::handleConfigConfig, this, std::placeholders::_1));
  DEF_HANDLE_index_html;
  DEF_HANDLE_switch_css;
  DEF_HANDLE_ESPresso_css;
  DEF_HANDLE_gauge_min_js;
  DEF_HANDLE_EspressoMachine_svg;
  DEF_HANDLE_drawtimeseries_js;
  DEF_HANDLE_firmware_js;
  DEF_HANDLE_configuration_html;
  DEF_HANDLE_configuration_helper_js;
  DEF_HANDLE_index_helper_js;
  DEF_HANDLE_redCircleCrossed_svg;
  DEF_HANDLE_networkSetup_html;
  DEF_HANDLE_networkConfigPage_js;
  //  DEF_HANDLE_test_html;

  // Handle Web Server Events
  events->onConnect(std::bind(&WebInterface::handleEventClient, this, std::placeholders::_1));
  server->addHandler(events);

  Serial.println("HTTP server started");
}

void WebInterface::handleEventClient(AsyncEventSourceClient *client)
{

  if (client->lastId())
  {
    Serial.printf("Client reconnected! Last message ID that it got is: %u\n", client->lastId());
  }
  // send event with message "hello!", id current millis
  // and set reconnect delay to 1 second
  client->send("hello!", NULL, millis(), myMachine->myConfig->pidInt);
}

void WebInterface::eventLoop()
{
  events->send(myMachine->machineStatus.c_str(), "status", millis());
}

void WebInterface::setConfigPortalPages()
{
  server->on("/scan", HTTP_GET, std::bind(&WebInterface::handleScan, this, std::placeholders::_1));
  server->on("/", HTTP_GET, std::bind(&WebInterface::handleCaptivePortal, this, std::placeholders::_1));
  server->on("/configConfig", HTTP_GET, std::bind(&WebInterface::handleConfigConfig, this, std::placeholders::_1));

  DEF_HANDLE_redCircleCrossed_svg;
  DEF_HANDLE_networkSetup_html;
  DEF_HANDLE_switch_css;
  DEF_HANDLE_ESPresso_css;
  DEF_HANDLE_networkConfigPage_js;
  DEF_HANDLE_captivePortal_html;

  return;
}

void WebInterface::handleCaptivePortal(AsyncWebServerRequest *request)
{
  LOGINFO("CalptivePortal Hit")
  waitingForClientAction = true;
  request->redirect("/captivePortal.html");
  return;
}

void WebInterface::handleScan(AsyncWebServerRequest *request)
{
  LOGINFO("Scan Handle");
  String json = "[";
  int n = WiFi.scanComplete();
  if (n == -2)
  {
    LOGERROR("Scanning no result, initiating no scan");
    WiFi.scanNetworks(true);
  }
  else if (n)
  {
    for (int i = 0; i < n; ++i)
    {
      if (i)
        json += ",";
      json += "{";
      json += "\"rssi\":" + String(WiFi.RSSI(i));
      json += ",\"ssid\":\"" + WiFi.SSID(i) + "\"";
      json += ",\"pass\":\"" + myMachine->myConfig->passForSSID(WiFi.SSID(i)) + "\"";
      json += ",\"bssid\":\"" + WiFi.BSSIDstr(i) + "\"";
      json += ",\"channel\":" + String(WiFi.channel(i));
      json += ",\"secure\":" + String(WiFi.encryptionType(i));
      json += "}";
    }
    WiFi.scanDelete();
    if (WiFi.scanComplete() == -2)
    {
      WiFi.scanNetworks(true);
    }
  }
  json += "]";
  request->send(200, "application/json", json);
  json = String();
};

// helper function for below checks whether a value is in a vectpr
using namespace std;
template <typename T>

bool contains(vector<T> vec, const T &elem)
{
  bool result = false;
  if (find(vec.begin(), vec.end(), elem) != vec.end())
  {
    result = true;
  }
  return result;
}

void WebInterface::handleConfigConfig(AsyncWebServerRequest *request)
{
  vector<String> wifinets;

  bool MQTT = false;
#ifdef ENABLE_MQTT
  MQTT = true;
#endif

  String json = "{";
  json += "\"maxNets\":" + String(NUM_WIFI_CREDENTIALS);
  json += ",\"mqtt\":" + String(MQTT);
#ifdef ENABLE_MQTT
  json += ",\"mqttHost\":\"" + String(myMachine->myConfig->mqttHost) + "\"";
  json += ",\"mqttPort\":" + String(myMachine->myConfig->mqttPort) ;
  json += ",\"mqttUser\":\"" + String(myMachine->myConfig->mqttUser) + "\"";
  json += ",\"mqttPass\":\"" + String(myMachine->myConfig->mqttPass) + "\"";
  json += ",\"mqttTopic\":\"" + String(myMachine->myConfig->mqttTopic) + "\"";
#endif
  json += ",\"wifiNets\":[";
  bool firstSSID = false;
  String networklist;
  for (int i = 0; i < NUM_WIFI_CREDENTIALS; i++)
  {
    String tmpssid = myMachine->myConfig->WM_config.WiFi_Creds[i].wifi_ssid;
    if (tmpssid && tmpssid != "")
    {
      if (!contains(wifinets, tmpssid))
      {
        wifinets.push_back(tmpssid);
      }
    }
  }

    for (int i = 0; i < wifinets.size(); i++)
    {
      if (i)
      {
        json += ", ";
      }
      json += "\""+wifinets[i]+"\"";
    }

  json += "]";
  json += "}";
  request->send(200, "application/json", json);
  json = String();
}